# .cursor/rules

## Language

* **All code, comments, and documentation must be in English only.**
* No Russian text in code, comments, variable names, or documentation.
* Error messages and user-facing strings should be in English.

## Tests: General Principles

* Write behavior, not implementation. Pattern: AAA or Given–When–Then.
* One purpose per test. Clear names: `should_<expectation>`.
* Tests are deterministic. Time, network, randomness — mock them.
* Tests are independent. Execution order doesn't matter.
* Fast unit tests. Integration and e2e — selectively, on critical paths.
* Data through factories/builders. Cover edge cases.
* Mock only external boundaries. Own logic — real.
* TDD discipline: red → green → refactor.
* Coverage — indicator, not goal. Threshold: 80–90% lines/branches.
* Snapshots only for stable structures/UI.
* Parallel execution without conflicts: isolated DB, ports, tmp.
* Flaky tests are forbidden. Retries — temporary measure, create ticket for root cause.

## Pyramid

* Unit: pure functions and services without I/O.
* Integration: real adapters (DB, broker, Redis) in isolation.
* Contract: consumer–provider (Pact) for external APIs.
* E2E: minimum happy-path + critical errors.
* Perf/Load: outside CI PR, but before release.

## Test Structure

```ts
describe('Module/case', () => {
  it('should <expectation>', async () => {
    // Arrange
    // Act
    // Assert
  });
});
```

## Data and Fixtures

* Factories: `makeUser(overrides?)`, `makeOrder(...)`.
* Fix Clock and Random.
* For DB: migrate once, then — transaction per test and rollback.

## Mocks and Stubs

* Mock HTTP, FS, queue, timers, UUID/Random.
* Don't mock lightweight utilities and pure functions.
* For Redis: namespace keys in integration environment.

## Contracts and Schemas

* Verify DTOs with JSON Schema on input and output.
* Contract tests between services. Version contracts.

## Error Checks

* Test not only happy-path: errors, timeouts, empty inputs.
* Invariants and guards — separate cases.

## Anti-patterns

* "One test checks everything".
* Mocks deep inside domain.
* Expectations on private methods.
* Dependency on real time/network.
* Huge snapshots.

## Quality Metrics

* Coverage: lines/branches/functions ≥ 80–90% for critical packages.
* Mutation score (Stryker) ≥ 70% for core.
* Flakiness = 0 in main.

## CI/PR

* Order: lint → typecheck → unit → integration (by label/folder) → e2e.
* Publish artifacts: coverage, junit, e2e screenshots.
* Tests — part of "Definition of Done".

## NestJS + Prisma + Redis (test generation rules)

* Unit (Jest/Vitest): services with mocked repositories/clients. Fix Clock/Random.
* Integration (Prisma): Testcontainers or separate test DB. Migrations → transaction per test → rollback.
* Redis: unit — mock client; integration — ephemeral Redis with unique namespace.
* E2E (NestJS): `@nestjs/testing` + `supertest`. Real HTTP. External services — mocked or via contract server.

## Required Cases

* Edges: empty collections, max lengths, duplicates, null/undefined.
* Idempotency, retries, deduplication.
* Transactional invariants "all or nothing".
* Concurrency: two parallel updates of one resource.
* Security: authorization, prohibition of changes to protected fields.
* Localization/encodings.
* DB migrations: `up`/`down` on empty and existing schema.

## Quick Rules

* Every found bug — new test.
* Any new public function — with test.
* Any contract change — update contract tests.
* Keep PR run time ≤ 5 minutes. Longer — shard or move heavy tests out.

## Tools (recommendations)

* Runner: Vitest or Jest.
* E2E: Supertest; for frontend — Playwright.
* Containers: Testcontainers.
* Coverage: Istanbul.
* Mutations: Stryker.
* Contracts: Pact.
* Factories: fishery/test-data-bot or custom builders.

## Unit Test Template (NestJS)

```ts
import { Test } from '@nestjs/testing';
import { MyService } from './my.service';
import { Repo } from './repo';

describe('MyService', () => {
  it('should create user with normalized email', async () => {
    const repo: Partial<Repo> = { create: vi.fn().mockResolvedValue({ id: 1 }) }; // jest.fn() if Jest
    const module = await Test.createTestingModule({
      providers: [MyService, { provide: Repo, useValue: repo }],
    }).compile();

    const svc = module.get(MyService);
    await expect(svc.create({ email: 'A@a.COM' })).resolves.toEqual({ id: 1 });
    expect(repo.create).toHaveBeenCalledWith({ email: 'a@a.com' });
  });
});
```

## E2E Template (NestJS + supertest)

```ts
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from '../src/app.module';

describe('App E2E', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({ imports: [AppModule] }).compile();
    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('GET /health should return ok', async () => {
    await request(app.getHttpServer()).get('/health').expect(200).expect({ status: 'ok' });
  });
});
```
